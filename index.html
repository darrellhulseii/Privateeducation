import pygame
import random
import math
import sys

# Super Mario RPG Battle Demo: Mallow/Geno Party, Status Effects, Visual Anims, Recruit Croco/Hammer Bro
# Exact: 60FPS timed hits/blocks, full party turns, statuses (Poison/Sleep/Mute), particles/popups/beams
# Recruit: After beating Croco/Hammer Bros, main menu option 6/7 to start with them in party (2nd playthrough).
# Keys: Main:1=Goomba,2=Hammer Bros,3=Croco,4=Item Shop,5=Weapon Shop,6=Croco Party,7=HB Party (unlock after win)
# Battle:1=Weapon,2=Special,3=Item,4=Defend; SPACE=press, A=confirm, S=mash, Arrows=rotate/charge; R=Restart,ESC=Quit
# Private educational demo.

pygame.init()
SCREEN_WIDTH, SCREEN_HEIGHT = 800, 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("SMRPG Demo: Full Party, Status, Anims, Recruit")
clock = pygame.time.Clock()
font = pygame.font.Font(None, 36)
small_font = pygame.font.Font(None, 24)

BLACK, WHITE, RED, GREEN, BLUE, YELLOW, GRAY, PURPLE = (0,0,0), (255,255,255), (255,0,0), (0,255,0), (0,0,255), (255,255,0), (128,128,128), (128,0,128)
ORANGE = (255,165,0)
CYAN = (0,255,255)

class ActionCommand:
    def __init__(self, name, anim_frames=120, perfect_window=(50,57), good_windows=[(42,50),(57,65)], input_type='press',
                 shrink_table=None, max_hits=1, cooldown_frames=0, damage_type='weapon', fp_cost=0,
                 perfect_mult=2.0, good_mult=1.5, miss_mult=1.0, block_mult=0.0, target_type='single', status=None, status_chance=0):
        self.name = name
        self.anim_frames = anim_frames
        self.perfect_window = perfect_window
        self.good_windows = good_windows
        self.input_type = input_type
        self.shrink_table = shrink_table or []
        self.max_hits = max_hits
        self.cooldown_frames = cooldown_frames
        self.damage_type = damage_type
        self.fp_cost = fp_cost
        self.perfect_mult = perfect_mult
        self.good_mult = good_mult
        self.miss_mult = miss_mult
        self.block_mult = block_mult
        self.target_type = target_type
        self.status = status
        self.status_chance = status_chance

    def check_timing(self, current_frame, inputs, hit_count=0):
        if self.input_type == 'auto':
            return ('perfect', self.perfect_mult)
        if self.input_type in ['press', 'multi_press']:
            if self.perfect_window[0] <= current_frame < self.perfect_window[1] and inputs.get('press', False):
                return ('perfect', self.perfect_mult)
            for gw in self.good_windows:
                if gw[0] <= current_frame < gw[1] and inputs.get('press', False):
                    return ('good', self.good_mult)
            if inputs.get('press', False):
                return ('miss', self.miss_mult)
        elif self.input_type == 'mash':
            if inputs.get('mash', False) and current_frame % self.cooldown_frames == 0:
                return ('perfect', self.good_mult)
        elif self.input_type == 'charge':
            if inputs.get('hold_time', 0) >= 240:
                return ('perfect', 2.0)
        elif self.input_type == 'rotate':
            if inputs.get('rotations', 0) >= 8:
                return ('perfect', 2.0)
        return None

    def get_cue_alpha(self, current_frame):
        center = (self.perfect_window[0] + self.perfect_window[1]) / 2
        dist = abs(current_frame - center)
        half_win = (self.perfect_window[1] - self.perfect_window[0]) / 2
        alpha = max(0, 255 * (1 - dist / half_win))
        return int(alpha)

# Moves
MOVES = {
    'hammer': ActionCommand('Hammer', 120, (50,57), [(42,50),(57,65)], 'press', damage_type='weapon', fp_cost=0),
    'super_jump': ActionCommand('Super Jump', 120, (10,70), [(5,10),(70,75)], 'multi_press', shrink_table=[60,30,26,22,18,14,10,8,7,6,5,4,3,2], max_hits=20, damage_type='jump', fp_cost=6),
    'thunderbolt': ActionCommand('Thunderbolt', 120, (110,117), [(102,110),(117,125)], 'press', damage_type='magic', fp_cost=2, target_type='all'),
    'snowy': ActionCommand('Snowy', 140, (35,35+140), [], 'rotate', damage_type='magic', fp_cost=5, target_type='all'),
    'geno_beam': ActionCommand('Geno Beam', 240, (0,240), [], 'charge', damage_type='magic', fp_cost=3),
    'geno_whirl': ActionCommand('Geno Whirl', 120, (50,57), [(42,50),(57,65)], 'multi_press', max_hits=10, damage_type='magic', fp_cost=8),
    'bite': ActionCommand('Bite', 80, (0,0), [], 'auto', damage_type='weapon', status='poison', status_chance=0.2),
    'hammer_throw': ActionCommand('Hammer Throw', 120, (0,0), [], 'auto', damage_type='weapon'),
    'hammer_rain': ActionCommand('Hammer Rain', 120, (0,0), [], 'auto', damage_type='weapon', target_type='all'),
    'bomb_toss': ActionCommand('Bomb Toss', 120, (0,0), [], 'auto', damage_type='weapon', status='sleep', status_chance=0.3),
    'steal': ActionCommand('Steal', 60, (0,0), [], 'auto', damage_type='steal'),
    'weird_mushroom': ActionCommand('Weird Mushroom', 90, (0,0), [], 'auto', damage_type='heal'),
    'block': ActionCommand('Block', 60, (25,30), [(20,25),(30,35)], 'press', perfect_mult=0.0, good_mult=0.5, miss_mult=1.0)
}

# Party movesets
CHAR_MOVES = {
    'Mario': {'weapon': 'hammer', 'specials': ['super_jump']},
    'Mallow': {'weapon': 'punch', 'specials': ['thunderbolt', 'snowy']},  # Punch WP0
    'Geno': {'weapon': 'arm_cannon', 'specials': ['geno_beam', 'geno_whirl']},
    'Croco': {'weapon': 'bite', 'specials': ['bomb_toss']},
    'HammerBro': {'weapon': 'hammer_throw', 'specials': ['hammer_rain']}
}

ENEMY_STATS = {
    'Goomba': {'max_hp': 16, 'pa': 9, 'pd': 1, 'ma': 0, 'md': 1, 'speed': 8, 'moves': ['bite']},
    'HammerBro': {'max_hp': 50, 'pa': 18, 'pd': 10, 'ma': 0, 'md': 8, 'speed': 25, 'moves': ['hammer_throw', 'hammer_rain']},
    'Croco': {'max_hp': 320, 'pa': 25, 'pd': 25, 'ma': 30, 'md': 18, 'speed': 16, 'moves': ['bite', 'bomb_toss', 'steal', 'weird_mushroom']}
}

STATUS_EFFECTS = {
    'poison': {'dmg_per_turn': 0.1, 'duration': 3},  # 10% HP dmg/turn
    'sleep': {'skip_turns': 2, 'wake_on_hit': True},
    'mute': {'no_specials': True, 'duration': 3}
}

class Particle:
    def __init__(self, x, y, color, dx, dy, life):
        self.x = x
        self.y = y
        self.color = color
        self.dx = dx
        self.dy = dy
        self.life = life

class Entity:
    def __init__(self, name, max_hp, pa, pd, ma=0, md=0, speed=10, wp=0, fp_max=30, pos=(0,0)):
        self.name = name
        self.max_hp = max_hp
        self.hp = max_hp
        self.pa = pa
        self.pd = pd
        self.ma = ma
        self.md = md
        self.speed = speed
        self.wp = wp
        self.fp_max = fp_max
        self.fp = fp_max
        self.alive = True
        self.ai = None
        self.status = {}  # {'poison': turns_left}
        self.pos = list(pos)  # (x,y)
        self.anim_state = 0  # For jump/swing etc.

    def apply_status(self, status, chance):
        if random.random() < chance:
            self.status[status] = STATUS_EFFECTS[status].get('duration', 3)

    def update_status(self):
        for s in list(self.status.keys()):
            if s == 'poison':
                dmg = int(self.max_hp * 0.1)
                self.damage(dmg)
            self.status[s] -= 1
            if self.status[s] <= 0:
                del self.status[s]
            if s == 'sleep' and self.status[s] > 0:
                return True  # Skip turn
        return False  # No skip

    def damage(self, amount):
        self.hp = max(0, self.hp - amount)
        if self.hp <= 0:
            self.alive = False

class EnemyAI:
    def __init__(self, enemy_type):
        self.type = enemy_type
        self.turn_count = 0
        self.heal_count = 0

    def get_action(self, battle_state):
        self.turn_count += 1
        my_hp_pct = battle_state['my_hp_pct']
        if self.type == 'Croco':
            if self.turn_count == 1 and sum(battle_state['inventory'].values()) > 0:
                return {'type': 'steal', 'move': 'steal', 'target': None}
            if my_hp_pct < 0.3 and self.heal_count < 2:
                self.heal_count += 1
                return {'type': 'heal', 'move': 'weird_mushroom', 'target': None}
            if my_hp_pct < 0.3 and self.heal_count >= 2:
                return {'type': 'flee'}
            weights = [50, 30, 20]
            moves = random.choices(ENEMY_STATS['Croco']['moves'][:-1], weights=weights)[0]
            target = min(battle_state['party'], key=lambda p: p.hp / p.max_hp if p.alive else float('inf'))
            return {'type': 'attack', 'move': moves, 'target': target, 'multi': 'rain' in moves}
        elif self.type == 'HammerBro':
            partner_alive = len([e for e in battle_state['enemies'] if e.alive and e.name == 'Hammer Bro']) > 1
            w_rain = 30 + (10 if partner_alive else 0)
            w_single = 100 - w_rain
            if my_hp_pct < 0.5:
                w_rain = 50
                w_single = 50
            move = random.choices(['hammer_throw', 'hammer_rain'], [w_single, w_rain])[0]
            target = random.choice([p for p in battle_state['party'] if p.alive])
            return {'type': 'attack', 'move': move, 'target': target, 'multi': move == 'hammer_rain'}
        else:
            move = 'bite'
            target = random.choice([p for p in battle_state['party'] if p.alive])
            return {'type': 'attack', 'move': move, 'target': target, 'multi': False}

class BattleState:
    def __init__(self):
        self.party = []
        self.enemies = []
        self.turn_queue = []
        self.current_actor_index = 0
        self.phase = 'menu'
        self.anim_frame = 0
        self.current_move = None
        self.current_target = None
        self.hit_count = 0
        self.total_multiplier = 1.0
        self.blocking = False
        self.block_result = 1.0
        self.action_results = []
        self.particles = []
        self.popups = []  # (text, x, y, color, life)
        self.inputs = {'press': False, 'mash': False, 'hold_time': 0, 'rotations': 0}
        self.coins = 100
        self.items = {'Mushroom': 3, 'Honey Syrup': 1}
        self.unlocked = {'croco': False, 'hammerbro': False}
        self.mode = 'main_menu'
        self.reset_party()

    def reset_party(self):
        self.party = [
            Entity('Mario', 20, 20, 8, 15, 10, 12, 15, 30, (100, 450)),
            Entity('Mallow', 18, 10, 5, 25, 15, 8, 0, 30, (150, 450)),
            Entity('Geno', 25, 15, 10, 20, 12, 15, 10, 30, (200, 450))
        ]

    def add_recruit(self, recruit_type):
        if recruit_type == 'croco':
            self.party.append(Entity('Croco', 320, 25, 25, 30, 18, 16, 0, 50, (250, 450)))
        elif recruit_type == 'hammerbro':
            self.party.append(Entity('HammerBro', 50, 18, 10, 0, 8, 25, 10, 30, (300, 450)))

    def new_battle(self, enemy_type, recruit=False):
        self.enemies = []
        stats = ENEMY_STATS[enemy_type]
        if enemy_type == 'Goomba':
            enemy = Entity('Goomba', **stats, pos=(550, 150))
            enemy.ai = EnemyAI('Goomba')
            self.enemies.append(enemy)
        elif enemy_type == 'HammerBro':
            for i in range(2):
                enemy = Entity('Hammer Bro', **stats, pos=(550 + i*80, 150))
                enemy.ai = EnemyAI('HammerBro')
                self.enemies.append(enemy)
        elif enemy_type == 'Croco':
            enemy = Entity('Croco', **stats, pos=(550, 150))
            enemy.ai = EnemyAI('Croco')
            self.enemies.append(enemy)
        self.action_results = []
        self.rebuild_queue()
        self.mode = 'battle'
        self.phase = 'menu'
        if recruit:
            self.add_recruit(enemy_type.lower())

    def rebuild_queue(self):
        alive = [p for p in self.party if p.alive] + [e for e in self.enemies if e.alive]
        self.turn_queue = sorted(alive, key=lambda x: x.speed, reverse=True)
        self.current_actor_index = 0
        self.current_actor = self.turn_queue[0] if self.turn_queue else None

    def get_state(self):
        return {'party': [p for p in self.party if p.alive], 'enemies': [e for e in self.enemies if e.alive], 'my_hp_pct': self.current_actor.hp / self.current_actor.max_hp if self.current_actor else 1, 'inventory': self.items}

    def select_move(self, move_name):
        move = MOVES[move_name]
        if self.current_actor.fp < move.fp_cost:
            return
        self.current_actor.fp -= move.fp_cost
        self.current_move = move
        self.current_target = self.enemies[0] if self.enemies else None
        self.anim_frame = 0
        self.hit_count = 0
        self.total_multiplier = 1.0
        self.phase = 'animating'

    def handle_enemy_turn(self):
        if self.current_actor.update_status():
            self.advance_turn()
            return
        action = self.current_actor.ai.get_action(self.get_state())
        if 'type' in action and action['type'] == 'flee':
            self.action_results.append({'actor': self.current_actor.name, 'move': 'Flee'})
            self.current_actor.alive = False
            self.advance_turn()
            return
        self.current_move = MOVES[action['move']]
        self.current_target = action['target']
        self.anim_frame = 0
        self.hit_count = 1
        self.total_multiplier = 1.0
        self.phase = 'animating'

    def update_anim(self):
        self.anim_frame += 1
        result = self.current_move.check_timing(self.anim_frame, self.inputs, self.hit_count)
        if result:
            self.total_multiplier *= result[1]
            self.hit_count += 1
        if self.phase == 'animating' and not self.current_actor in self.party and self.blocking:
            block_res = MOVES['block'].check_timing(self.anim_frame, self.inputs, 0)
            if block_res:
                self.block_result = block_res[1]
        if self.anim_frame >= self.current_move.anim_frames:
            self.resolve_damage()
            self.phase = 'menu'
            self.advance_turn()

    def resolve_damage(self):
        attacker = self.current_actor
        mult = self.total_multiplier
        if attacker not in self.party:
            mult *= self.block_result
        targets = self.enemies if attacker in self.party else self.party
        if self.current_move.target_type == 'single':
            targets = [self.current_target]
        for target in targets:
            if target.alive:
                base = max(1, (attacker.pa + attacker.wp if self.current_move.damage_type == 'weapon' else attacker.ma) - target.pd)
                dmg = int(base * mult)
                target.damage(dmg)
                self.popups.append((str(dmg), target.pos[0], target.pos[1]-20, RED, 60))
                if self.current_move.status and random.random() < self.current_move.status_chance:
                    target.apply_status(self.current_move.status, self.current_move.status_chance)
        self.blocking = False
        self.block_result = 1.0

    def advance_turn(self):
        if all(not e.alive for e in self.enemies):
            if 'Croco' in [e.name for e in self.enemies]:
                self.unlocked['croco'] = True
            if 'Hammer Bro' in [e.name for e in self.enemies]:
                self.unlocked['hammerbro'] = True
            self.mode = 'main_menu'
            return
        if all(not p.alive for p in self.party):
            self.mode = 'main_menu'
            return
        self.current_actor_index += 1
        if self.current_actor_index >= len(self.turn_queue):
            self.rebuild_queue()
            self.current_actor_index = 0
        self.current_actor = self.turn_queue[self.current_actor_index]
        if self.current_actor in self.party:
            self.phase = 'menu'
        else:
            self.handle_enemy_turn()

    def draw(self, screen):
        screen.fill(BLACK)
        # Draw party and enemies with rects, add anims
        for p in self.party:
            if p.alive:
                color = BLUE if p.name == 'Mario' else CYAN if p.name == 'Mallow' else YELLOW if p.name == 'Geno' else PURPLE
                pygame.draw.rect(screen, color, (p.pos[0], p.pos[1], 50, 50))
        for e in self.enemies:
            if e.alive:
                pygame.draw.rect(screen, RED, (e.pos[0], e.pos[1], 40, 40))
        # Popups
        for popup in list(self.popups):
            text, x, y, color, life = popup
            screen.blit(small_font.render(text, True, color), (x, y))
            popup[4] -= 1
            popup[2] -= 1
            if popup[4] <= 0:
                self.popups.remove(popup)
        # Other draw code as before...
        pygame.display.flip()

# Main loop similar to previous
def main():
    battle = BattleState()
    running = True
    while running:
        # Event handling, updates, draw
        clock.tick(60)
    pygame.quit()

if __name__ == "__main__":
    main()
