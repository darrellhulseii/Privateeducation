import pygame
import random
import math
import sys

# Super Mario RPG Battle Demo: Complete Unified Version
# Features: Peach Party, Bowser Boss, Leveling, Enemy AI, Timed Hits/Blocks
# Exact mechanics: 60FPS timed hits/blocks/AI/status/XP level up, particles/popups/menus
# Unlocks: Beat bosses to recruit to party options. Bowser unlocks Peach.
# Keys: Main Menu 1-4 Battles, 5-9 Party Select (unlocked); Battle: Arrows sel menu, SPACE exec/timing, S=mash, LSHIFT=charge; R=Restart, ESC=Quit
# Private educational demo - for personal use only.

pygame.init()
SCREEN_WIDTH, SCREEN_HEIGHT = 800, 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("SMRPG Demo: Complete Battle System")
clock = pygame.time.Clock()
font = pygame.font.Font(None, 36)
small_font = pygame.font.Font(None, 24)

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
GRAY = (128, 128, 128)
PURPLE = (128, 0, 128)
ORANGE = (255, 165, 0)
CYAN = (0, 255, 255)
PINK = (255, 192, 203)

class ActionCommand:
    """Defines action commands with timing windows and mechanics"""
    def __init__(self, name, anim_frames=120, perfect_window=(50, 57), good_windows=[(42, 50), (57, 65)],
                 input_type='press', shrink_table=None, max_hits=1, cooldown_frames=0,
                 damage_type='weapon', fp_cost=0, perfect_mult=2.0, good_mult=1.5, miss_mult=1.0,
                 target_type='single', status=None, status_chance=0.0):
        self.name = name
        self.anim_frames = anim_frames
        self.perfect_window = perfect_window
        self.good_windows = good_windows
        self.input_type = input_type
        self.shrink_table = shrink_table or []
        self.max_hits = max_hits
        self.cooldown_frames = cooldown_frames
        self.damage_type = damage_type  # weapon, magic, jump, heal, heal_party, steal
        self.fp_cost = fp_cost
        self.perfect_mult = perfect_mult
        self.good_mult = good_mult
        self.miss_mult = miss_mult
        self.target_type = target_type
        self.status = status
        self.status_chance = status_chance

    def get_window_size(self, hit_count=0):
        if self.shrink_table and hit_count < len(self.shrink_table):
            return self.shrink_table[hit_count]
        return self.perfect_window[1] - self.perfect_window[0]

    def check_timing(self, current_frame, inputs, hit_count=0):
        """Check if timing input matches windows"""
        if self.input_type == 'auto':
            return ('perfect', self.perfect_mult)
        
        press = inputs.get('press', False)
        
        if self.input_type in ['press', 'multi_press']:
            if self.perfect_window[0] <= current_frame < self.perfect_window[1]:
                return ('perfect', self.perfect_mult)
            for gw in self.good_windows:
                if gw[0] <= current_frame < gw[1]:
                    return ('good', self.good_mult)
            if press:
                return ('miss', self.miss_mult)
        elif self.input_type == 'mash':
            if inputs.get('mash', False) and current_frame % self.cooldown_frames == 0:
                return ('perfect', self.good_mult)
        elif self.input_type == 'charge':
            hold = inputs.get('hold_time', 0)
            mult = 1.0 + min(1.0, hold / 120.0)
            if hold > 10:  # Started charging
                return ('good', mult)
        elif self.input_type == 'rotate':
            rots = inputs.get('rotations', 0)
            if rots >= 8:
                return ('perfect', self.perfect_mult)
            elif rots >= 4:
                return ('good', self.good_mult)
        return None

    def get_cue_alpha(self, current_frame):
        """Calculate visual cue alpha based on timing window"""
        center = (self.perfect_window[0] + self.perfect_window[1]) / 2
        dist = abs(current_frame - center)
        half_win = (self.perfect_window[1] - self.perfect_window[0]) / 2
        alpha = max(0, 255 * (1 - dist / half_win))
        return int(alpha)

# Move definitions (exact SMRPG timing/formulas)
MOVES = {
    # Basic attacks
    'hammer': ActionCommand('Hammer', 120, (50, 57), [(42, 50), (57, 65)], 'press', damage_type='weapon', perfect_mult=2.0, good_mult=1.5),
    'punch': ActionCommand('Punch', 100, (40, 47), [(35, 40), (47, 52)], 'press', damage_type='weapon'),
    'parasol': ActionCommand('Parasol', 110, (45, 52), [(40, 45), (52, 57)], 'press', damage_type='weapon'),
    'arm_cannon': ActionCommand('Arm Cannon', 130, (55, 62), [(50, 55), (62, 67)], 'press', damage_type='weapon'),
    'bite': ActionCommand('Bite', 80, (0, 0), [], 'auto', damage_type='weapon', status='poison', status_chance=0.2),
    'hammer_throw': ActionCommand('Hammer Throw', 120, (0, 0), [], 'auto', damage_type='weapon'),
    'headbonk': ActionCommand('Headbonk', 90, (0, 0), [], 'auto', damage_type='weapon'),
    
    # Special moves
    'super_jump': ActionCommand('Super Jump', 180, (10, 70), [(5, 10), (70, 75)], 'multi_press',
                               shrink_table=[60, 30, 26, 22, 18, 14, 10, 8, 7, 6, 5, 4, 3, 2],
                               max_hits=20, damage_type='jump', fp_cost=6),
    'thunderbolt': ActionCommand('Thunderbolt', 120, (110, 117), [(102, 110), (117, 125)], 'press',
                                damage_type='magic', target_type='all', fp_cost=2),
    'snowy': ActionCommand('Snowy', 140, (35, 42), [(30, 35), (42, 47)], 'rotate',
                          damage_type='magic', target_type='all', fp_cost=5),
    'geno_beam': ActionCommand('Geno Beam', 240, (0, 240), [], 'charge', damage_type='magic', fp_cost=3),
    'geno_whirl': ActionCommand('Geno Whirl', 120, (50, 57), [(42, 50), (57, 65)], 'multi_press',
                               max_hits=10, damage_type='magic', fp_cost=8),
    'peach_bomb': ActionCommand('Peach Bomb', 180, (20, 27), [], 'mash', cooldown_frames=8,
                                max_hits=12, damage_type='magic', target_type='all', fp_cost=6),
    'serenity': ActionCommand('Serenity', 90, (30, 37), [(25, 30), (37, 42)], 'press',
                             damage_type='heal_party', fp_cost=12),
    'bomb_toss': ActionCommand('Bomb Toss', 120, (0, 0), [], 'auto', damage_type='magic',
                              status='sleep', status_chance=0.3),
    'hammer_rain': ActionCommand('Hammer Rain', 120, (0, 0), [], 'auto', damage_type='weapon', target_type='all'),
    'fire_breath': ActionCommand('Fire Breath', 150, (0, 0), [], 'auto', damage_type='magic', target_type='all'),
    
    # Utility
    'steal': ActionCommand('Steal', 60, (0, 0), [], 'auto', damage_type='steal'),
    'weird_mushroom': ActionCommand('Weird Mushroom', 90, (0, 0), [], 'auto', damage_type='heal'),
    'block': ActionCommand('Block', 60, (25, 30), [(20, 25), (30, 35)], 'press',
                          perfect_mult=0.0, good_mult=0.5, miss_mult=1.0)
}

# Character weapon mappings
CHAR_WEAPON = {
    'Mario': 'hammer',
    'Mallow': 'punch',
    'Geno': 'arm_cannon',
    'Peach': 'parasol',
    'Croco': 'bite',
    'HammerBro': 'hammer_throw'
}

# Character special moves
CHAR_SPECIALS = {
    'Mario': ['super_jump'],
    'Mallow': ['thunderbolt', 'snowy'],
    'Geno': ['geno_beam', 'geno_whirl'],
    'Peach': ['peach_bomb', 'serenity'],
    'Croco': ['bomb_toss'],
    'HammerBro': ['hammer_rain']
}

# Base stats: (max_hp, pa, pd, ma, md, speed, wp, fp_max)
PARTY_BASE_STATS = {
    'Mario': (20, 20, 8, 15, 10, 12, 15, 30),
    'Mallow': (18, 10, 5, 25, 15, 8, 0, 30),
    'Geno': (25, 15, 10, 20, 12, 15, 10, 30),
    'Peach': (22, 14, 14, 28, 22, 22, 7, 35),
    'Croco': (35, 22, 18, 12, 14, 14, 0, 25),
    'HammerBro': (45, 20, 15, 8, 10, 28, 12, 20)
}

# Enemy stats
ENEMY_STATS = {
    'Goomba': {'max_hp': 16, 'pa': 9, 'pd': 1, 'ma': 0, 'md': 1, 'speed': 8},
    'HammerBro': {'max_hp': 50, 'pa': 18, 'pd': 10, 'ma': 0, 'md': 8, 'speed': 25},
    'Croco': {'max_hp': 320, 'pa': 25, 'pd': 25, 'ma': 30, 'md': 18, 'speed': 16},
    'Bowser': {'max_hp': 700, 'pa': 50, 'pd': 40, 'ma': 40, 'md': 30, 'speed': 20}
}

# XP rewards
XP_REWARDS = {
    'goomba': 15,
    'hammerbros': 120,
    'croco': 250,
    'bowser': 500
}

class Particle:
    """Visual particle effects"""
    def __init__(self, x, y, vx, vy, color, life):
        self.x = x
        self.y = y
        self.vx = vx
        self.vy = vy
        self.color = color
        self.life = life
        self.max_life = life

    def update(self):
        self.x += self.vx
        self.y += self.vy
        self.vy += 0.15  # Gravity
        self.vx *= 0.97  # Air resistance
        self.life -= 1
        return self.life > 0

class Entity:
    """Base class for characters and enemies"""
    def __init__(self, name, max_hp, pa, pd, ma=0, md=0, speed=10, wp=0, fp_max=30, pos=(0, 0)):
        self.name = name
        self.max_hp = max_hp
        self.hp = max_hp
        self.pa = pa
        self.pd = pd
        self.ma = ma
        self.md = md
        self.speed = speed
        self.wp = wp
        self.fp = fp_max
        self.fp_max = fp_max
        self.pos = pos
        self.alive = True
        self.ai = None
        self.status = {}
        self.level = 1
        self.xp = 0
        self.next_level_xp = 100

    def damage(self, amount):
        """Apply damage to entity"""
        self.hp = max(0, self.hp - amount)
        if self.hp == 0:
            self.alive = False

class EnemyAI:
    """AI controller for enemies"""
    def __init__(self, enemy_type):
        self.type = enemy_type
        self.turn_count = 0

    def get_action(self, battle_state):
        """Determine enemy action based on type and battle state"""
        self.turn_count += 1
        
        # Select moves based on enemy type
        if self.type == 'Goomba':
            moves = ['bite']
        elif self.type == 'HammerBro':
            moves = ['hammer_throw', 'hammer_rain'] if self.turn_count % 3 == 0 else ['hammer_throw']
        elif self.type == 'Croco':
            if battle_state['my_hp_pct'] < 0.3:
                moves = ['bomb_toss', 'steal']
            else:
                moves = ['bite', 'steal']
        elif self.type == 'Bowser':
            if battle_state['my_hp_pct'] < 0.5:
                moves = ['fire_breath']
            else:
                moves = ['bite', 'headbonk']
        else:
            moves = ['bite']
        
        move_name = random.choice(moves)
        
        # Target lowest HP party member
        alive_party = [p for p in battle_state['party'] if p.alive]
        if not alive_party:
            return {'type': 'flee'}
        
        target = min(alive_party, key=lambda p: p.hp / p.max_hp if p.max_hp > 0 else 999)
        
        return {'move': move_name, 'target': target}

class BattleState:
    """Main battle system controller"""
    def __init__(self):
        self.reset_game()

    def reset_game(self):
        """Reset entire game state"""
        self.party = []
        self.enemies = []
        self.turn_queue = []
        self.current_actor_index = 0
        self.current_actor = None
        self.phase = 'main_menu'
        self.battle_phase = 'menu'
        self.menu_options = []
        self.menu_sel = 0
        self.anim_frame = 0
        self.current_move = None
        self.current_target = None
        self.hit_count = 0
        self.total_multiplier = 1.0
        self.blocking = False
        self.block_result = 1.0
        self.action_results = []
        self.particles = []
        self.popups = []
        self.inputs = {'press': False, 'mash': False, 'hold_time': 0, 'rotations': 0}
        self.prev_dir = -1
        self.coins = 100
        self.items = {'Mushroom': 3, 'Honey Syrup': 1}
        self.unlocked = {'croco': False, 'hammerbro': False, 'peach': False}
        self.enemy_type = None
        self.reset_party()

    def reset_party(self):
        """Reset party to default (Mario, Mallow, Geno)"""
        self.party = []
        base_names = ['Mario', 'Mallow', 'Geno']
        for i, name in enumerate(base_names):
            stats = PARTY_BASE_STATS[name]
            p = Entity(name, *stats, pos=(100 + i * 55, 450))
            p.level = 1
            p.xp = 0
            p.next_level_xp = 100
            p.ai = None
            self.party.append(p)

    def set_party_preset(self, preset):
        """Set party composition based on preset"""
        self.reset_party()
        if preset == 'peach' and self.unlocked['peach']:
            self.add_party_member('Peach')
        elif preset == 'croco' and self.unlocked['croco']:
            self.add_party_member('Croco')
        elif preset == 'hammerbro' and self.unlocked['hammerbro']:
            self.add_party_member('HammerBro')

    def add_party_member(self, name):
        """Add a new party member"""
        if name not in PARTY_BASE_STATS:
            return
        stats = PARTY_BASE_STATS[name]
        pos_x = 100 + len(self.party) * 55
        p = Entity(name, *stats, pos=(pos_x, 450))
        p.level = 3  # Recruits start stronger
        p.xp = 0
        p.next_level_xp = 150
        p.ai = None
        self.party.append(p)

    def new_battle(self, enemy_type):
        """Initialize a new battle encounter"""
        self.enemies = []
        self.enemy_type = enemy_type
        
        if enemy_type == 'goomba':
            stats = ENEMY_STATS['Goomba']
            e = Entity('Goomba', stats['max_hp'], stats['pa'], stats['pd'], 
                      stats['ma'], stats['md'], stats['speed'], pos=(550, 150))
            e.ai = EnemyAI('Goomba')
            self.enemies.append(e)
        elif enemy_type == 'hammerbros':
            stats = ENEMY_STATS['HammerBro']
            for i in range(2):
                e = Entity('Hammer Bro', stats['max_hp'], stats['pa'], stats['pd'],
                          stats['ma'], stats['md'], stats['speed'], pos=(530 + i * 60, 150))
                e.ai = EnemyAI('HammerBro')
                self.enemies.append(e)
        elif enemy_type == 'croco':
            stats = ENEMY_STATS['Croco']
            e = Entity('Croco', stats['max_hp'], stats['pa'], stats['pd'],
                      stats['ma'], stats['md'], stats['speed'], pos=(550, 150))
            e.ai = EnemyAI('Croco')
            self.enemies.append(e)
        elif enemy_type == 'bowser':
            stats = ENEMY_STATS['Bowser']
            e = Entity('Bowser', stats['max_hp'], stats['pa'], stats['pd'],
                      stats['ma'], stats['md'], stats['speed'], pos=(550, 120))
            e.ai = EnemyAI('Bowser')
            self.enemies.append(e)
        
        self.action_results = []
        self.particles = []
        self.popups = []
        self.rebuild_turn_queue()
        self.battle_phase = 'menu'
        self.phase = 'battle'

    def rebuild_turn_queue(self):
        """Rebuild turn order based on speed"""
        alive = [a for a in self.party + self.enemies if a.alive]
        self.turn_queue = sorted(alive, key=lambda a: a.speed + random.random() * 0.1, reverse=True)
        self.current_actor_index = 0
        if self.turn_queue:
            self.current_actor = self.turn_queue[0]
            self.build_menu_options()

    def build_menu_options(self):
        """Build menu options for current actor"""
        actor = self.current_actor
        if actor.ai is not None:
            return
        
        self.menu_options = [CHAR_WEAPON.get(actor.name, 'punch')]
        
        # Add special moves if enough FP
        specials = CHAR_SPECIALS.get(actor.name, [])
        for s in specials:
            move = MOVES[s]
            if actor.fp >= move.fp_cost:
                self.menu_options.append(s)
        
        # Add items if available
        if sum(self.items.values()) > 0:
            self.menu_options.append('item')
        
        self.menu_options.append('defend')
        self.menu_sel = 0

    def handle_status(self, actor):
        """Process status effects, returns True if turn should be skipped"""
        skip = False
        
        if 'sleep' in actor.status:
            actor.status['sleep'] -= 1
            if actor.status['sleep'] <= 0:
                del actor.status['sleep']
            else:
                skip = True
        
        if 'poison' in actor.status:
            dmg = int(actor.max_hp * 0.05)
            actor.damage(dmg)
            self.popups.append({
                'text': f'Poison! -{dmg}',
                'x': actor.pos[0],
                'y': actor.pos[1] - 30,
                'color': PURPLE,
                'life': 60,
                'vy': -1
            })
            actor.status['poison'] -= 1
            if actor.status['poison'] <= 0:
                del actor.status['poison']
        
        if 'mute' in actor.status:
            actor.status['mute'] -= 1
            if actor.status['mute'] <= 0:
                del actor.status['mute']
        
        return skip

    def player_select_option(self, opt):
        """Handle player menu selection"""
        if opt == 'defend':
            self.blocking = True
            self.battle_phase = 'defending'
            return
        elif opt == 'item':
            # Use item
            if 'Mushroom' in self.items and self.items['Mushroom'] > 0:
                heal = 40
                self.party[0].hp = min(self.party[0].max_hp, self.party[0].hp + heal)
                self.items['Mushroom'] -= 1
                self.action_results.append({
                    'actor': 'Mario',
                    'move': 'Used Mushroom',
                    'heal': heal
                })
            elif 'Honey Syrup' in self.items and self.items['Honey Syrup'] > 0:
                heal = 30
                self.party[0].fp = min(self.party[0].fp_max, self.party[0].fp + heal)
                self.items['Honey Syrup'] -= 1
                self.action_results.append({
                    'actor': 'Mario',
                    'move': 'Used Honey Syrup',
                    'heal': heal
                })
            self.advance_turn()
            return
        
        # Execute move
        move_key = opt
        move = MOVES[move_key]
        
        if self.current_actor.fp < move.fp_cost:
            return
        
        self.current_actor.fp -= move.fp_cost
        self.current_move = move
        
        if move.target_type == 'single':
            self.current_target = next((e for e in self.enemies if e.alive), None)
        
        self.anim_frame = 0
        self.hit_count = 0
        self.total_multiplier = 1.0
        self.battle_phase = 'animating'

    def enemy_get_action(self):
        """Get enemy action from AI"""
        state = self.get_battle_state()
        return self.current_actor.ai.get_action(state)

    def get_battle_state(self):
        """Get current battle state for AI"""
        return {
            'party': self.party,
            'enemies': self.enemies,
            'inventory': self.items,
            'my_hp_pct': self.current_actor.hp / self.current_actor.max_hp
        }

    def update_battle(self):
        """Update battle state each frame"""
        if self.battle_phase == 'animating':
            self.anim_frame += 1
            
            # Check timing
            result = self.current_move.check_timing(self.anim_frame, self.inputs, self.hit_count)
            if result:
                self.total_multiplier *= result[1]
                self.hit_count += 1
                print(f"{self.current_actor.name}: {result[0]} hit! ({result[1]}x)")
            
            # Spawn particles for visual effects
            if self.anim_frame % 4 == 0 and self.current_move.damage_type in ['magic', 'jump']:
                px, py = self.current_actor.pos
                for _ in range(4):
                    vx = random.uniform(-3, 3)
                    vy = random.uniform(-4, 0)
                    self.particles.append(Particle(px + 25, py + 25, vx, vy, YELLOW, 40))
            
            # Check for block timing during enemy attack
            if self.current_actor.ai is not None and self.blocking and self.block_result == 1.0:
                block_res = MOVES['block'].check_timing(self.anim_frame, self.inputs, 0)
                if block_res:
                    self.block_result = block_res[1]
            
            # End animation
            if self.anim_frame >= self.current_move.anim_frames or \
               (self.current_move.max_hits and self.hit_count >= self.current_move.max_hits):
                self.resolve_action()
                self.advance_turn()
        
        elif self.battle_phase == 'defending':
            self.advance_turn()

    def resolve_action(self):
        """Resolve the current action's effects"""
        actor = self.current_actor
        move = self.current_move
        mult = self.total_multiplier
        
        # Apply block multiplier if enemy attacking
        if actor.ai is not None:
            mult *= self.block_result
        
        targets = []
        
        # Handle special action types
        if move.damage_type == 'steal':
            total = sum(self.items.values())
            if total > 0:
                item_keys = [k for k, v in self.items.items() for _ in range(v)]
                stolen = random.choice(item_keys)
                self.items[stolen] -= 1
                self.action_results.append({
                    'actor': actor.name,
                    'move': f'Stole {stolen}!',
                    'steal': True
                })
            return
        
        elif move.damage_type == 'heal':
            amt = int((50 + random.randint(30, 70)) * mult)
            actor.hp = min(actor.max_hp, actor.hp + amt)
            self.action_results.append({
                'actor': actor.name,
                'move': move.name,
                'heal': amt
            })
            self.popups.append({
                'text': f'+{amt}',
                'x': actor.pos[0] + 10,
                'y': actor.pos[1] - 20,
                'color': GREEN,
                'life': 60,
                'vy': -1
            })
            return
        
        elif move.damage_type == 'heal_party':
            amt = int((25 + random.randint(10, 20)) * mult)
            for p in self.party:
                if p.alive:
                    p.hp = min(p.max_hp, p.hp + amt)
                    self.popups.append({
                        'text': f'+{amt}',
                        'x': p.pos[0] + 10,
                        'y': p.pos[1] - 20,
                        'color': GREEN,
                        'life': 60,
                        'vy': -1
                    })
            self.action_results.append({
                'actor': actor.name,
                'move': move.name,
                'heal': 'Party'
            })
            return
        
        # Handle damage moves
        if move.target_type == 'all':
            targets = [t for t in self.enemies if t.alive] if actor.ai is None else [t for t in self.party if t.alive]
        else:
            targets = [self.current_target] if self.current_target and self.current_target.alive else []
        
        for target in targets:
            base_atk = actor.pa + actor.wp if move.damage_type == 'weapon' else actor.ma
            base_def = target.pd if move.damage_type == 'weapon' else target.md
            p_var = random.randint(-4, 4)
            base_dmg = max(1, base_atk + p_var - base_def)
            dmg = int(base_dmg * mult)
            
            # Special jump damage calculation
            if move.damage_type == 'jump':
                dmg = int((base_atk + 25 + self.hit_count * 3 - base_def) * mult)
            
            target.damage(dmg)
            
            # Add damage popup
            self.popups.append({
                'text': str(dmg),
                'x': target.pos[0] + 15 - (len(str(dmg)) * 4),
                'y': target.pos[1] - 25,
                'color': RED,
                'life': 75,
                'vy': -2
            })
            
            # Apply status effect
            if move.status and random.random() < move.status_chance:
                target.status[move.status] = 3  # Duration
            
            self.action_results.append({
                'actor': actor.name,
                'move': move.name,
                'target': target.name,
                'damage': dmg
            })
        
        self.blocking = False
        self.block_result = 1.0

    def advance_turn(self):
        """Move to next turn"""
        # Check victory
        if all(not e.alive for e in self.enemies):
            self.award_xp()
            
            # Unlock recruitable characters
            if self.enemy_type == 'croco':
                self.unlocked['croco'] = True
            elif self.enemy_type == 'hammerbros':
                self.unlocked['hammerbro'] = True
            elif self.enemy_type == 'bowser':
                self.unlocked['peach'] = True
            
            self.action_results.append({
                'actor': 'VICTORY!',
                'move': f'{self.enemy_type.upper()} Defeated!'
            })
            pygame.time.wait(2000)
            self.phase = 'main_menu'
            return
        
        # Check game over
        if all(not p.alive for p in self.party):
            self.action_results.append({
                'actor': 'GAME OVER!',
                'move': 'Try Again'
            })
            pygame.time.wait(2000)
            self.new_battle('goomba')
            return
        
        # Next actor
        self.current_actor_index = (self.current_actor_index + 1) % len(self.turn_queue)
        if self.current_actor_index >= len(self.turn_queue):
            self.rebuild_turn_queue()
            return
        
        self.current_actor = self.turn_queue[self.current_actor_index]
        
        # Handle status effects
        if self.handle_status(self.current_actor):
            self.action_results.append({
                'actor': self.current_actor.name,
                'move': 'Status Skip...'
            })
            self.advance_turn()
            return
        
        # Player turn
        if self.current_actor.ai is None:
            self.battle_phase = 'menu'
            self.build_menu_options()
        # Enemy turn
        else:
            self.battle_phase = 'animating'
            action = self.enemy_get_action()
            
            if action.get('type') == 'flee':
                self.current_actor.alive = False
                self.action_results.append({
                    'actor': self.current_actor.name,
                    'move': 'Fled!'
                })
                self.advance_turn()
                return
            
            self.current_move = MOVES[action['move']]
            self.current_target = action['target']
            self.anim_frame = 0
            self.hit_count = 1
            self.total_multiplier = 1.0

    def award_xp(self):
        """Award XP after battle victory"""
        reward = XP_REWARDS[self.enemy_type]
        alive_party_count = len([p for p in self.party if p.alive])
        share = reward // max(1, alive_party_count)
        
        for p in self.party:
            if p.alive:
                p.xp += share
                self.do_level_up(p)

    def do_level_up(self, entity):
        """Handle level up and stat increases"""
        while entity.xp >= entity.next_level_xp:
            entity.xp -= entity.next_level_xp
            entity.level += 1
            entity.next_level_xp = int(entity.next_level_xp * 1.5 + 50)
            
            # Stat increases
            entity.max_hp += random.randint(12, 28)
            entity.pa += random.randint(1, 4)
            entity.pd += random.randint(1, 3)
            entity.ma += random.randint(2, 6)
            entity.md += random.randint(1, 4)
            entity.speed += random.randint(0, 2)
            entity.fp_max += random.randint(8, 20)
            
            # Restore to full
            entity.hp = entity.max_hp
            entity.fp = entity.fp_max
            
            self.popups.append({
                'text': f'Lv{entity.level}!',
                'x': entity.pos[0],
                'y': entity.pos[1] - 50,
                'color': YELLOW,
                'life': 120,
                'vy': -1
            })
            
            self.action_results.append({
                'actor': entity.name,
                'move': f'Leveled to {entity.level}!'
            })

    def update(self):
        """Main update loop"""
        if self.phase == 'battle':
            self.update_battle()
        
        # Update visual effects
        self.particles = [p for p in self.particles if p.update()]
        
        for popup in self.popups[:]:
            popup['y'] += popup['vy']
            popup['vy'] += 0.08
            popup['life'] -= 1
            if popup['life'] <= 0:
                self.popups.remove(popup)

    def draw(self, screen):
        """Render everything to screen"""
        screen.fill(BLACK)

        if self.phase == 'main_menu':
            y = 50
            screen.blit(font.render('BATTLES:', True, WHITE), (50, y))
            y += 50
            
            screen.blit(small_font.render('1. Goomba', True, YELLOW), (70, y))
            y += 35
            screen.blit(small_font.render('2. Hammer Bros Duo', True, YELLOW), (70, y))
            y += 35
            screen.blit(small_font.render('3. Croco', True, YELLOW), (70, y))
            y += 35
            screen.blit(small_font.render('4. Bowser Boss', True, YELLOW), (70, y))
            y += 50
            
            screen.blit(font.render('PARTY PRESETS:', True, WHITE), (50, y))
            y += 50
            screen.blit(small_font.render('5. Default (Mario+Mallow+Geno)', True, YELLOW), (70, y))
            y += 35
            
            if self.unlocked['peach']:
                screen.blit(small_font.render('6. Peach Party', True, YELLOW), (70, y))
                y += 35
            if self.unlocked['croco']:
                screen.blit(small_font.render('7. Croco Party', True, YELLOW), (70, y))
                y += 35
            if self.unlocked['hammerbro']:
                screen.blit(small_font.render('8. Hammer Bro Party', True, YELLOW), (70, y))
                y += 35
            
            y += 20
            screen.blit(small_font.render(f'Coins: {self.coins}', True, WHITE), (50, y))
            y += 25
            unlocks_text = f"R=Reset | Unlocks: Peach:{self.unlocked['peach']} Croco:{self.unlocked['croco']} HB:{self.unlocked['hammerbro']}"
            screen.blit(small_font.render(unlocks_text, True, WHITE), (50, y))

        elif self.phase == 'battle':
            # Draw party members
            for i, p in enumerate(self.party):
                if p.alive:
                    colors = {
                        'Mario': BLUE,
                        'Mallow': CYAN,
                        'Geno': YELLOW,
                        'Peach': PINK,
                        'Croco': ORANGE,
                        'HammerBro': RED
                    }
                    col = colors.get(p.name, GREEN)
                    
                    # Pulse effect during action
                    size_mod = 0
                    if p == self.current_actor and self.battle_phase == 'animating':
                        size_mod = math.sin(self.anim_frame * 0.2) * 3
                    
                    pygame.draw.rect(screen, col, 
                                   (p.pos[0] + size_mod, p.pos[1] + size_mod,
                                    50 - abs(size_mod) * 2, 50 - abs(size_mod) * 2))
                    
                    # HP bar
                    hp_w = (p.hp / p.max_hp) * 100
                    pygame.draw.rect(screen, GRAY, (p.pos[0], p.pos[1] - 35, 100, 8))
                    pygame.draw.rect(screen, GREEN if hp_w > 30 else RED,
                                   (p.pos[0], p.pos[1] - 35, hp_w, 8))
                    
                    # FP bar
                    fp_w = (p.fp / p.fp_max) * 100 if p.fp_max > 0 else 0
                    pygame.draw.rect(screen, GRAY, (p.pos[0], p.pos[1] - 25, 100, 6))
                    pygame.draw.rect(screen, BLUE, (p.pos[0], p.pos[1] - 25, fp_w, 6))
                    
                    # Status and level
                    status_str = '/'.join(p.status.keys()) if p.status else ''
                    lv_str = f"{p.name} Lv{p.level} {status_str}"
                    screen.blit(small_font.render(lv_str, True, WHITE), (p.pos[0], p.pos[1] - 60))
                    screen.blit(small_font.render(f"HP:{int(p.hp)}/{p.max_hp}", True, WHITE),
                              (p.pos[0], p.pos[1] - 15))

            # Draw enemies
            for e in self.enemies:
                if e.alive:
                    col = PURPLE if e.name == 'Bowser' else RED
                    
                    size_mod = 0
                    if e == self.current_actor and self.battle_phase == 'animating':
                        size_mod = math.sin(self.anim_frame * 0.2) * 3
                    
                    pygame.draw.rect(screen, col,
                                   (e.pos[0] + size_mod, e.pos[1] + size_mod,
                                    60 - abs(size_mod) * 2, 50 - abs(size_mod) * 2))
                    
                    # HP bar
                    hp_w = (e.hp / e.max_hp) * 120
                    pygame.draw.rect(screen, GRAY, (e.pos[0] - 20, e.pos[1] - 25, 120, 10))
                    pygame.draw.rect(screen, GREEN if hp_w > 30 else RED,
                                   (e.pos[0] - 20, e.pos[1] - 25, hp_w, 10))
                    screen.blit(small_font.render(f"{e.name} HP:{int(e.hp)}", True, WHITE),
                              (e.pos[0] - 20, e.pos[1] - 40))

            # Menu
            if self.battle_phase == 'menu' and self.current_actor.ai is None:
                for i, opt in enumerate(self.menu_options):
                    col = YELLOW if i == self.menu_sel else WHITE
                    move_name = MOVES[opt].name if opt not in ['defend', 'item'] else opt.title()
                    screen.blit(font.render(f"{i + 1}. {move_name}", True, col), (50, 50 + i * 35))
                
                screen.blit(small_font.render("Arrows: Select | SPACE: Execute/Timing | S: Mash | LSHIFT: Charge",
                                             True, WHITE), (50, 300))

            # Animation bar
            elif self.battle_phase == 'animating':
                is_player = self.current_actor.ai is None
                bar_x = 100 if is_player else 450
                bar_w = 350
                prog = min(1.0, self.anim_frame / self.current_move.anim_frames)
                
                pygame.draw.rect(screen, GRAY, (bar_x, 320, bar_w, 25))
                pygame.draw.rect(screen, BLUE, (bar_x, 320, bar_w * prog, 25))
                
                # Sweet spot
                sweet_size = ((self.current_move.perfect_window[1] - self.current_move.perfect_window[0]) /
                            self.current_move.anim_frames * bar_w)
                sweet_pos = bar_x + (self.current_move.perfect_window[0] / self.current_move.anim_frames * bar_w)
                pygame.draw.rect(screen, GREEN, (sweet_pos, 320, sweet_size, 25))
                
                # Cursor
                cursor_pos = bar_x + prog * bar_w + math.sin(self.anim_frame * 0.4) * 15
                pygame.draw.rect(screen, WHITE, (cursor_pos - 3, 320, 6, 25))
                
                # ! cue
                alpha = self.current_move.get_cue_alpha(self.anim_frame)
                if alpha > 0:
                    excl = font.render('!', True, YELLOW)
                    excl.set_alpha(alpha)
                    y_cue = 260 if is_player else 100
                    screen.blit(excl, (bar_x + bar_w // 2 - 10, y_cue))
                
                # Info text
                info = f"{self.current_actor.name}: {self.current_move.name} | F:{self.anim_frame} | Hits:{self.hit_count} | Mult:{self.total_multiplier:.1f}x"
                screen.blit(font.render(info, True, WHITE), (50, 360))

                # Block bar during enemy attack
                if not is_player and self.blocking:
                    b_prog = min(1.0, self.anim_frame / 60)
                    pygame.draw.rect(screen, GRAY, (150, 400, 300, 20))
                    pygame.draw.rect(screen, BLUE, (150, 400, 300 * b_prog, 20))
                    b_sweet = 150 + 25 / 60 * 300
                    pygame.draw.rect(screen, GREEN, (b_sweet - 8, 400, 16, 20))
                    screen.blit(small_font.render("Block Now!", True, WHITE), (50, 430))

            # Action log
            for i, res in enumerate(self.action_results[-8:]):
                if 'VICTORY' in str(res) or 'heal' in str(res):
                    col = GREEN
                elif 'Leveled' in str(res):
                    col = YELLOW
                elif 'damage' in str(res):
                    col = RED
                else:
                    col = WHITE
                
                line = f"{res.get('actor', '?')}: {res.get('move', '?')}"
                if 'heal' in res:
                    line += f" +{res.get('heal', '')}"
                elif 'damage' in res:
                    line += f" {res.get('damage', '')}"
                
                screen.blit(small_font.render(line[:55], True, col),
                          (50, SCREEN_HEIGHT - 150 + i * 18))

            # Coins/Items
            info = f"Coins: {self.coins} | Mush:{self.items.get('Mushroom', 0)} Honey:{self.items.get('Honey Syrup', 0)}"
            screen.blit(small_font.render(info, True, WHITE), (450, SCREEN_HEIGHT - 30))

        # Particles
        for p in self.particles:
            size = max(1, int(p.life / p.max_life * 4))
            pygame.draw.circle(screen, p.color, (int(p.x), int(p.y)), size)
        
        # Popups
        for popup in self.popups:
            text = small_font.render(popup['text'], True, popup['color'])
            screen.blit(text, (popup['x'], popup['y']))

        pygame.display.flip()

def main():
    """Main game loop"""
    state = BattleState()
    running = True
    
    while running:
        clock.tick(60)  # 60 FPS
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
                running = False
            
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r:
                    state.reset_game()
                
                # Main menu selections
                if state.phase == 'main_menu':
                    if event.key == pygame.K_1:
                        state.new_battle('goomba')
                    elif event.key == pygame.K_2:
                        state.new_battle('hammerbros')
                    elif event.key == pygame.K_3:
                        state.new_battle('croco')
                    elif event.key == pygame.K_4:
                        state.new_battle('bowser')
                    elif event.key == pygame.K_5:
                        state.set_party_preset('default')
                        state.new_battle('goomba')
                    elif event.key == pygame.K_6 and state.unlocked['peach']:
                        state.set_party_preset('peach')
                        state.new_battle('goomba')
                    elif event.key == pygame.K_7 and state.unlocked['croco']:
                        state.set_party_preset('croco')
                        state.new_battle('goomba')
                    elif event.key == pygame.K_8 and state.unlocked['hammerbro']:
                        state.set_party_preset('hammerbro')
                        state.new_battle('goomba')
                
                # Battle menu navigation
                elif state.phase == 'battle' and state.battle_phase == 'menu':
                    if event.key == pygame.K_UP:
                        state.menu_sel = (state.menu_sel - 1) % len(state.menu_options)
                    elif event.key == pygame.K_DOWN:
                        state.menu_sel = (state.menu_sel + 1) % len(state.menu_options)
                    elif event.key == pygame.K_SPACE:
                        state.player_select_option(state.menu_options[state.menu_sel])

        # Continuous input checks
        keys = pygame.key.get_pressed()
        state.inputs['press'] = keys[pygame.K_SPACE]
        state.inputs['mash'] = keys[pygame.K_s]
        state.inputs['hold_time'] += 1 if keys[pygame.K_LSHIFT] else -state.inputs['hold_time']
        state.inputs['hold_time'] = max(0, state.inputs['hold_time'])
        
        # Rotation detection
        dirs = [pygame.K_UP, pygame.K_RIGHT, pygame.K_DOWN, pygame.K_LEFT]
        curr_dir = -1
        for idx, k in enumerate(dirs):
            if keys[k]:
                curr_dir = idx
                break
        
        if curr_dir != state.prev_dir and curr_dir != -1:
            state.inputs['rotations'] += 1
        state.prev_dir = curr_dir

        state.update()
        state.draw(screen)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
